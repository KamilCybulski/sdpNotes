## Main Topics

* This module expands a bit on the phases and the models (There are other modules that go in greater detail for each of the models)

## Sotware Development Phases

1. Requirements Engineering - establishing the needs of stakeholders that are to be solved by software
Set of steps - iterative process
* Elicitation - I am not sure what this is
* Analysis
* Specification
* Verification
* Maintainance

My understanding of this phase is basically a number of meetings and talks with the stakeholders (customers, product users) in order to determine what exactly do they need. This is not done by the developers, there is a separate role in the team, a person whose job is to go and talk to the clients, ask them questions and try to capture their needs in a form of detailed specification.

2. Design
From high level to low level of the system

Based on the specification provided, a detailed design (a technical specification) is created. That documentation has to be in place before the developers start coding. That is how they know what they need to build.

3. Implementation
4 pillars:
* Reduction of complexity
* Anticipation of diversity
* Design for testability
* Use of (external) standards

4. Verification and Validation (Testing)
* Did we build the right system?
* Did we build the system right?

5. Maintainance
* Corrective (Fixing bugs)
* Perfective (New features)
* Adaptive (New Enviroments - libraries, OS etc.)

## Software lifecycle model
Determines the order of the activities and the transition criteria
1. Waterfall model

* Pros: Finds errors early
* Con: It is not flexible

2. Spiral model - iterative 

* Pros: Risk reduction, Adding functionality is easy..
* Cons: Risk evaluation requires expertise, can be costly

3. Evolutionary Prototyping 

* Pros: Immediate feedback
* Cons: Difficult to plan

4. Rational Unified Process (RUP)

5. Agile (group of methods)

* TDD 
* Extreme programming
* SCRUM

## How to chose a model?
Basically, the choice depends on number of factors: 

* Our level of understanding of the requirements
* Expected lifetime
* What is the risk involved?
* What is the schedule?
* The interaction with the customer
* The level of expertise

## Classic mistakes
i am not too worried about the mistakes due to the nature of our project. I liked the link provided in the class notes that lists all the classic mistakes. [Classic Mistakes Enumerated](http://www.stevemcconnell.com/rdenum.htm) I just skimmed it, seems like it is more relevant for project managers(that we might become one day) than it is for junior developers(that we ar at the moment).

## Relation to our project

I agree all the points you made on this section. Waterfall models seems most appropriate. We should strive for good specification and  design before we start coding. Be realistic about the features we want, and have a very clear vision of the app's architecture and design.

It is useful to know that there are standardized template documents created by IEEE, but they are a bit heavyweight, so they provide modified versions of them. These document templates might be useful for us, as a guide. We do not have to follow them strictly.

[Document templates](https://www.udacity.com/wiki/sdp/projects#!#docs)


